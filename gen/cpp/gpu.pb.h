// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gpu.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_gpu_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_gpu_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_gpu_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_gpu_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_gpu_2eproto;
namespace cedanagpu {
class AvailableCUDAAPIs;
class AvailableCUDAAPIsDefaultTypeInternal;
extern AvailableCUDAAPIsDefaultTypeInternal _AvailableCUDAAPIs_default_instance_;
class CheckpointRequest;
class CheckpointRequestDefaultTypeInternal;
extern CheckpointRequestDefaultTypeInternal _CheckpointRequest_default_instance_;
class CheckpointResponse;
class CheckpointResponseDefaultTypeInternal;
extern CheckpointResponseDefaultTypeInternal _CheckpointResponse_default_instance_;
class GPURestoreStats;
class GPURestoreStatsDefaultTypeInternal;
extern GPURestoreStatsDefaultTypeInternal _GPURestoreStats_default_instance_;
class HealthCheckRequest;
class HealthCheckRequestDefaultTypeInternal;
extern HealthCheckRequestDefaultTypeInternal _HealthCheckRequest_default_instance_;
class HealthCheckResponse;
class HealthCheckResponseDefaultTypeInternal;
extern HealthCheckResponseDefaultTypeInternal _HealthCheckResponse_default_instance_;
class RestoreRequest;
class RestoreRequestDefaultTypeInternal;
extern RestoreRequestDefaultTypeInternal _RestoreRequest_default_instance_;
class RestoreResponse;
class RestoreResponseDefaultTypeInternal;
extern RestoreResponseDefaultTypeInternal _RestoreResponse_default_instance_;
class StartupPollRequest;
class StartupPollRequestDefaultTypeInternal;
extern StartupPollRequestDefaultTypeInternal _StartupPollRequest_default_instance_;
class StartupPollResponse;
class StartupPollResponseDefaultTypeInternal;
extern StartupPollResponseDefaultTypeInternal _StartupPollResponse_default_instance_;
}  // namespace cedanagpu
PROTOBUF_NAMESPACE_OPEN
template<> ::cedanagpu::AvailableCUDAAPIs* Arena::CreateMaybeMessage<::cedanagpu::AvailableCUDAAPIs>(Arena*);
template<> ::cedanagpu::CheckpointRequest* Arena::CreateMaybeMessage<::cedanagpu::CheckpointRequest>(Arena*);
template<> ::cedanagpu::CheckpointResponse* Arena::CreateMaybeMessage<::cedanagpu::CheckpointResponse>(Arena*);
template<> ::cedanagpu::GPURestoreStats* Arena::CreateMaybeMessage<::cedanagpu::GPURestoreStats>(Arena*);
template<> ::cedanagpu::HealthCheckRequest* Arena::CreateMaybeMessage<::cedanagpu::HealthCheckRequest>(Arena*);
template<> ::cedanagpu::HealthCheckResponse* Arena::CreateMaybeMessage<::cedanagpu::HealthCheckResponse>(Arena*);
template<> ::cedanagpu::RestoreRequest* Arena::CreateMaybeMessage<::cedanagpu::RestoreRequest>(Arena*);
template<> ::cedanagpu::RestoreResponse* Arena::CreateMaybeMessage<::cedanagpu::RestoreResponse>(Arena*);
template<> ::cedanagpu::StartupPollRequest* Arena::CreateMaybeMessage<::cedanagpu::StartupPollRequest>(Arena*);
template<> ::cedanagpu::StartupPollResponse* Arena::CreateMaybeMessage<::cedanagpu::StartupPollResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace cedanagpu {

// ===================================================================

class CheckpointRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cedanagpu.CheckpointRequest) */ {
 public:
  inline CheckpointRequest() : CheckpointRequest(nullptr) {};
  virtual ~CheckpointRequest();

  CheckpointRequest(const CheckpointRequest& from);
  CheckpointRequest(CheckpointRequest&& from) noexcept
    : CheckpointRequest() {
    *this = ::std::move(from);
  }

  inline CheckpointRequest& operator=(const CheckpointRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckpointRequest& operator=(CheckpointRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CheckpointRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CheckpointRequest* internal_default_instance() {
    return reinterpret_cast<const CheckpointRequest*>(
               &_CheckpointRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CheckpointRequest& a, CheckpointRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckpointRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckpointRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CheckpointRequest* New() const final {
    return CreateMaybeMessage<CheckpointRequest>(nullptr);
  }

  CheckpointRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CheckpointRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CheckpointRequest& from);
  void MergeFrom(const CheckpointRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckpointRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cedanagpu.CheckpointRequest";
  }
  protected:
  explicit CheckpointRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_gpu_2eproto);
    return ::descriptor_table_gpu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDirectoryFieldNumber = 1,
  };
  // string directory = 1[json_name = "directory"];
  void clear_directory();
  const std::string& directory() const;
  void set_directory(const std::string& value);
  void set_directory(std::string&& value);
  void set_directory(const char* value);
  void set_directory(const char* value, size_t size);
  std::string* mutable_directory();
  std::string* release_directory();
  void set_allocated_directory(std::string* directory);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_directory();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_directory(
      std::string* directory);
  private:
  const std::string& _internal_directory() const;
  void _internal_set_directory(const std::string& value);
  std::string* _internal_mutable_directory();
  public:

  // @@protoc_insertion_point(class_scope:cedanagpu.CheckpointRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr directory_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gpu_2eproto;
};
// -------------------------------------------------------------------

class CheckpointResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cedanagpu.CheckpointResponse) */ {
 public:
  inline CheckpointResponse() : CheckpointResponse(nullptr) {};
  virtual ~CheckpointResponse();

  CheckpointResponse(const CheckpointResponse& from);
  CheckpointResponse(CheckpointResponse&& from) noexcept
    : CheckpointResponse() {
    *this = ::std::move(from);
  }

  inline CheckpointResponse& operator=(const CheckpointResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckpointResponse& operator=(CheckpointResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CheckpointResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CheckpointResponse* internal_default_instance() {
    return reinterpret_cast<const CheckpointResponse*>(
               &_CheckpointResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CheckpointResponse& a, CheckpointResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckpointResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckpointResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CheckpointResponse* New() const final {
    return CreateMaybeMessage<CheckpointResponse>(nullptr);
  }

  CheckpointResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CheckpointResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CheckpointResponse& from);
  void MergeFrom(const CheckpointResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckpointResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cedanagpu.CheckpointResponse";
  }
  protected:
  explicit CheckpointResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_gpu_2eproto);
    return ::descriptor_table_gpu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMemPathFieldNumber = 2,
    kCkptPathFieldNumber = 3,
    kSuccessFieldNumber = 1,
  };
  // string memPath = 2[json_name = "memPath"];
  void clear_mempath();
  const std::string& mempath() const;
  void set_mempath(const std::string& value);
  void set_mempath(std::string&& value);
  void set_mempath(const char* value);
  void set_mempath(const char* value, size_t size);
  std::string* mutable_mempath();
  std::string* release_mempath();
  void set_allocated_mempath(std::string* mempath);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_mempath();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_mempath(
      std::string* mempath);
  private:
  const std::string& _internal_mempath() const;
  void _internal_set_mempath(const std::string& value);
  std::string* _internal_mutable_mempath();
  public:

  // string ckptPath = 3[json_name = "ckptPath"];
  void clear_ckptpath();
  const std::string& ckptpath() const;
  void set_ckptpath(const std::string& value);
  void set_ckptpath(std::string&& value);
  void set_ckptpath(const char* value);
  void set_ckptpath(const char* value, size_t size);
  std::string* mutable_ckptpath();
  std::string* release_ckptpath();
  void set_allocated_ckptpath(std::string* ckptpath);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_ckptpath();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_ckptpath(
      std::string* ckptpath);
  private:
  const std::string& _internal_ckptpath() const;
  void _internal_set_ckptpath(const std::string& value);
  std::string* _internal_mutable_ckptpath();
  public:

  // bool success = 1[json_name = "success"];
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:cedanagpu.CheckpointResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mempath_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ckptpath_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gpu_2eproto;
};
// -------------------------------------------------------------------

class RestoreRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cedanagpu.RestoreRequest) */ {
 public:
  inline RestoreRequest() : RestoreRequest(nullptr) {};
  virtual ~RestoreRequest();

  RestoreRequest(const RestoreRequest& from);
  RestoreRequest(RestoreRequest&& from) noexcept
    : RestoreRequest() {
    *this = ::std::move(from);
  }

  inline RestoreRequest& operator=(const RestoreRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RestoreRequest& operator=(RestoreRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RestoreRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RestoreRequest* internal_default_instance() {
    return reinterpret_cast<const RestoreRequest*>(
               &_RestoreRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RestoreRequest& a, RestoreRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RestoreRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RestoreRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RestoreRequest* New() const final {
    return CreateMaybeMessage<RestoreRequest>(nullptr);
  }

  RestoreRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RestoreRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RestoreRequest& from);
  void MergeFrom(const RestoreRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RestoreRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cedanagpu.RestoreRequest";
  }
  protected:
  explicit RestoreRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_gpu_2eproto);
    return ::descriptor_table_gpu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDirectoryFieldNumber = 1,
  };
  // string directory = 1[json_name = "directory"];
  void clear_directory();
  const std::string& directory() const;
  void set_directory(const std::string& value);
  void set_directory(std::string&& value);
  void set_directory(const char* value);
  void set_directory(const char* value, size_t size);
  std::string* mutable_directory();
  std::string* release_directory();
  void set_allocated_directory(std::string* directory);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_directory();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_directory(
      std::string* directory);
  private:
  const std::string& _internal_directory() const;
  void _internal_set_directory(const std::string& value);
  std::string* _internal_mutable_directory();
  public:

  // @@protoc_insertion_point(class_scope:cedanagpu.RestoreRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr directory_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gpu_2eproto;
};
// -------------------------------------------------------------------

class RestoreResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cedanagpu.RestoreResponse) */ {
 public:
  inline RestoreResponse() : RestoreResponse(nullptr) {};
  virtual ~RestoreResponse();

  RestoreResponse(const RestoreResponse& from);
  RestoreResponse(RestoreResponse&& from) noexcept
    : RestoreResponse() {
    *this = ::std::move(from);
  }

  inline RestoreResponse& operator=(const RestoreResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RestoreResponse& operator=(RestoreResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RestoreResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RestoreResponse* internal_default_instance() {
    return reinterpret_cast<const RestoreResponse*>(
               &_RestoreResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RestoreResponse& a, RestoreResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RestoreResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RestoreResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RestoreResponse* New() const final {
    return CreateMaybeMessage<RestoreResponse>(nullptr);
  }

  RestoreResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RestoreResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RestoreResponse& from);
  void MergeFrom(const RestoreResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RestoreResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cedanagpu.RestoreResponse";
  }
  protected:
  explicit RestoreResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_gpu_2eproto);
    return ::descriptor_table_gpu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGpuRestoreStatsFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // .cedanagpu.GPURestoreStats gpuRestoreStats = 2[json_name = "gpuRestoreStats"];
  bool has_gpurestorestats() const;
  private:
  bool _internal_has_gpurestorestats() const;
  public:
  void clear_gpurestorestats();
  const ::cedanagpu::GPURestoreStats& gpurestorestats() const;
  ::cedanagpu::GPURestoreStats* release_gpurestorestats();
  ::cedanagpu::GPURestoreStats* mutable_gpurestorestats();
  void set_allocated_gpurestorestats(::cedanagpu::GPURestoreStats* gpurestorestats);
  private:
  const ::cedanagpu::GPURestoreStats& _internal_gpurestorestats() const;
  ::cedanagpu::GPURestoreStats* _internal_mutable_gpurestorestats();
  public:
  void unsafe_arena_set_allocated_gpurestorestats(
      ::cedanagpu::GPURestoreStats* gpurestorestats);
  ::cedanagpu::GPURestoreStats* unsafe_arena_release_gpurestorestats();

  // bool success = 1[json_name = "success"];
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:cedanagpu.RestoreResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::cedanagpu::GPURestoreStats* gpurestorestats_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gpu_2eproto;
};
// -------------------------------------------------------------------

class StartupPollRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cedanagpu.StartupPollRequest) */ {
 public:
  inline StartupPollRequest() : StartupPollRequest(nullptr) {};
  virtual ~StartupPollRequest();

  StartupPollRequest(const StartupPollRequest& from);
  StartupPollRequest(StartupPollRequest&& from) noexcept
    : StartupPollRequest() {
    *this = ::std::move(from);
  }

  inline StartupPollRequest& operator=(const StartupPollRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartupPollRequest& operator=(StartupPollRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StartupPollRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StartupPollRequest* internal_default_instance() {
    return reinterpret_cast<const StartupPollRequest*>(
               &_StartupPollRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(StartupPollRequest& a, StartupPollRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StartupPollRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartupPollRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StartupPollRequest* New() const final {
    return CreateMaybeMessage<StartupPollRequest>(nullptr);
  }

  StartupPollRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StartupPollRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StartupPollRequest& from);
  void MergeFrom(const StartupPollRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartupPollRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cedanagpu.StartupPollRequest";
  }
  protected:
  explicit StartupPollRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_gpu_2eproto);
    return ::descriptor_table_gpu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cedanagpu.StartupPollRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gpu_2eproto;
};
// -------------------------------------------------------------------

class StartupPollResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cedanagpu.StartupPollResponse) */ {
 public:
  inline StartupPollResponse() : StartupPollResponse(nullptr) {};
  virtual ~StartupPollResponse();

  StartupPollResponse(const StartupPollResponse& from);
  StartupPollResponse(StartupPollResponse&& from) noexcept
    : StartupPollResponse() {
    *this = ::std::move(from);
  }

  inline StartupPollResponse& operator=(const StartupPollResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartupPollResponse& operator=(StartupPollResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StartupPollResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StartupPollResponse* internal_default_instance() {
    return reinterpret_cast<const StartupPollResponse*>(
               &_StartupPollResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(StartupPollResponse& a, StartupPollResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StartupPollResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartupPollResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StartupPollResponse* New() const final {
    return CreateMaybeMessage<StartupPollResponse>(nullptr);
  }

  StartupPollResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StartupPollResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StartupPollResponse& from);
  void MergeFrom(const StartupPollResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartupPollResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cedanagpu.StartupPollResponse";
  }
  protected:
  explicit StartupPollResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_gpu_2eproto);
    return ::descriptor_table_gpu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1[json_name = "success"];
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:cedanagpu.StartupPollResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gpu_2eproto;
};
// -------------------------------------------------------------------

class HealthCheckRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cedanagpu.HealthCheckRequest) */ {
 public:
  inline HealthCheckRequest() : HealthCheckRequest(nullptr) {};
  virtual ~HealthCheckRequest();

  HealthCheckRequest(const HealthCheckRequest& from);
  HealthCheckRequest(HealthCheckRequest&& from) noexcept
    : HealthCheckRequest() {
    *this = ::std::move(from);
  }

  inline HealthCheckRequest& operator=(const HealthCheckRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HealthCheckRequest& operator=(HealthCheckRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HealthCheckRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HealthCheckRequest* internal_default_instance() {
    return reinterpret_cast<const HealthCheckRequest*>(
               &_HealthCheckRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(HealthCheckRequest& a, HealthCheckRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HealthCheckRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HealthCheckRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HealthCheckRequest* New() const final {
    return CreateMaybeMessage<HealthCheckRequest>(nullptr);
  }

  HealthCheckRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HealthCheckRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HealthCheckRequest& from);
  void MergeFrom(const HealthCheckRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HealthCheckRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cedanagpu.HealthCheckRequest";
  }
  protected:
  explicit HealthCheckRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_gpu_2eproto);
    return ::descriptor_table_gpu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cedanagpu.HealthCheckRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gpu_2eproto;
};
// -------------------------------------------------------------------

class HealthCheckResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cedanagpu.HealthCheckResponse) */ {
 public:
  inline HealthCheckResponse() : HealthCheckResponse(nullptr) {};
  virtual ~HealthCheckResponse();

  HealthCheckResponse(const HealthCheckResponse& from);
  HealthCheckResponse(HealthCheckResponse&& from) noexcept
    : HealthCheckResponse() {
    *this = ::std::move(from);
  }

  inline HealthCheckResponse& operator=(const HealthCheckResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HealthCheckResponse& operator=(HealthCheckResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HealthCheckResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HealthCheckResponse* internal_default_instance() {
    return reinterpret_cast<const HealthCheckResponse*>(
               &_HealthCheckResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(HealthCheckResponse& a, HealthCheckResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HealthCheckResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HealthCheckResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HealthCheckResponse* New() const final {
    return CreateMaybeMessage<HealthCheckResponse>(nullptr);
  }

  HealthCheckResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HealthCheckResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HealthCheckResponse& from);
  void MergeFrom(const HealthCheckResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HealthCheckResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cedanagpu.HealthCheckResponse";
  }
  protected:
  explicit HealthCheckResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_gpu_2eproto);
    return ::descriptor_table_gpu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 2,
    kAvailableCUDAAPIsFieldNumber = 4,
    kSuccessFieldNumber = 1,
    kDeviceCountFieldNumber = 3,
  };
  // string version = 2[json_name = "version"];
  void clear_version();
  const std::string& version() const;
  void set_version(const std::string& value);
  void set_version(std::string&& value);
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  std::string* mutable_version();
  std::string* release_version();
  void set_allocated_version(std::string* version);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_version();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_version(
      std::string* version);
  private:
  const std::string& _internal_version() const;
  void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // .cedanagpu.AvailableCUDAAPIs availableCUDAAPIs = 4[json_name = "availableCUDAAPIs"];
  bool has_availablecudaapis() const;
  private:
  bool _internal_has_availablecudaapis() const;
  public:
  void clear_availablecudaapis();
  const ::cedanagpu::AvailableCUDAAPIs& availablecudaapis() const;
  ::cedanagpu::AvailableCUDAAPIs* release_availablecudaapis();
  ::cedanagpu::AvailableCUDAAPIs* mutable_availablecudaapis();
  void set_allocated_availablecudaapis(::cedanagpu::AvailableCUDAAPIs* availablecudaapis);
  private:
  const ::cedanagpu::AvailableCUDAAPIs& _internal_availablecudaapis() const;
  ::cedanagpu::AvailableCUDAAPIs* _internal_mutable_availablecudaapis();
  public:
  void unsafe_arena_set_allocated_availablecudaapis(
      ::cedanagpu::AvailableCUDAAPIs* availablecudaapis);
  ::cedanagpu::AvailableCUDAAPIs* unsafe_arena_release_availablecudaapis();

  // bool success = 1[json_name = "success"];
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // int32 deviceCount = 3[json_name = "deviceCount"];
  void clear_devicecount();
  ::PROTOBUF_NAMESPACE_ID::int32 devicecount() const;
  void set_devicecount(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_devicecount() const;
  void _internal_set_devicecount(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:cedanagpu.HealthCheckResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::cedanagpu::AvailableCUDAAPIs* availablecudaapis_;
  bool success_;
  ::PROTOBUF_NAMESPACE_ID::int32 devicecount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gpu_2eproto;
};
// -------------------------------------------------------------------

class AvailableCUDAAPIs PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cedanagpu.AvailableCUDAAPIs) */ {
 public:
  inline AvailableCUDAAPIs() : AvailableCUDAAPIs(nullptr) {};
  virtual ~AvailableCUDAAPIs();

  AvailableCUDAAPIs(const AvailableCUDAAPIs& from);
  AvailableCUDAAPIs(AvailableCUDAAPIs&& from) noexcept
    : AvailableCUDAAPIs() {
    *this = ::std::move(from);
  }

  inline AvailableCUDAAPIs& operator=(const AvailableCUDAAPIs& from) {
    CopyFrom(from);
    return *this;
  }
  inline AvailableCUDAAPIs& operator=(AvailableCUDAAPIs&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AvailableCUDAAPIs& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AvailableCUDAAPIs* internal_default_instance() {
    return reinterpret_cast<const AvailableCUDAAPIs*>(
               &_AvailableCUDAAPIs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AvailableCUDAAPIs& a, AvailableCUDAAPIs& b) {
    a.Swap(&b);
  }
  inline void Swap(AvailableCUDAAPIs* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AvailableCUDAAPIs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AvailableCUDAAPIs* New() const final {
    return CreateMaybeMessage<AvailableCUDAAPIs>(nullptr);
  }

  AvailableCUDAAPIs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AvailableCUDAAPIs>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AvailableCUDAAPIs& from);
  void MergeFrom(const AvailableCUDAAPIs& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AvailableCUDAAPIs* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cedanagpu.AvailableCUDAAPIs";
  }
  protected:
  explicit AvailableCUDAAPIs(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_gpu_2eproto);
    return ::descriptor_table_gpu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCuDNNVersionFieldNumber = 1,
    kCuBLASVersionFieldNumber = 2,
    kNcclVersionFieldNumber = 3,
    kDriverVersionFieldNumber = 4,
    kRuntimeVersionFieldNumber = 5,
  };
  // int32 cuDNNVersion = 1[json_name = "cuDNNVersion"];
  void clear_cudnnversion();
  ::PROTOBUF_NAMESPACE_ID::int32 cudnnversion() const;
  void set_cudnnversion(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_cudnnversion() const;
  void _internal_set_cudnnversion(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 cuBLASVersion = 2[json_name = "cuBLASVersion"];
  void clear_cublasversion();
  ::PROTOBUF_NAMESPACE_ID::int32 cublasversion() const;
  void set_cublasversion(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_cublasversion() const;
  void _internal_set_cublasversion(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 ncclVersion = 3[json_name = "ncclVersion"];
  void clear_ncclversion();
  ::PROTOBUF_NAMESPACE_ID::int32 ncclversion() const;
  void set_ncclversion(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_ncclversion() const;
  void _internal_set_ncclversion(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 driverVersion = 4[json_name = "driverVersion"];
  void clear_driverversion();
  ::PROTOBUF_NAMESPACE_ID::int32 driverversion() const;
  void set_driverversion(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_driverversion() const;
  void _internal_set_driverversion(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 runtimeVersion = 5[json_name = "runtimeVersion"];
  void clear_runtimeversion();
  ::PROTOBUF_NAMESPACE_ID::int32 runtimeversion() const;
  void set_runtimeversion(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_runtimeversion() const;
  void _internal_set_runtimeversion(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:cedanagpu.AvailableCUDAAPIs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 cudnnversion_;
  ::PROTOBUF_NAMESPACE_ID::int32 cublasversion_;
  ::PROTOBUF_NAMESPACE_ID::int32 ncclversion_;
  ::PROTOBUF_NAMESPACE_ID::int32 driverversion_;
  ::PROTOBUF_NAMESPACE_ID::int32 runtimeversion_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gpu_2eproto;
};
// -------------------------------------------------------------------

class GPURestoreStats PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cedanagpu.GPURestoreStats) */ {
 public:
  inline GPURestoreStats() : GPURestoreStats(nullptr) {};
  virtual ~GPURestoreStats();

  GPURestoreStats(const GPURestoreStats& from);
  GPURestoreStats(GPURestoreStats&& from) noexcept
    : GPURestoreStats() {
    *this = ::std::move(from);
  }

  inline GPURestoreStats& operator=(const GPURestoreStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline GPURestoreStats& operator=(GPURestoreStats&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GPURestoreStats& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GPURestoreStats* internal_default_instance() {
    return reinterpret_cast<const GPURestoreStats*>(
               &_GPURestoreStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GPURestoreStats& a, GPURestoreStats& b) {
    a.Swap(&b);
  }
  inline void Swap(GPURestoreStats* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GPURestoreStats* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GPURestoreStats* New() const final {
    return CreateMaybeMessage<GPURestoreStats>(nullptr);
  }

  GPURestoreStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GPURestoreStats>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GPURestoreStats& from);
  void MergeFrom(const GPURestoreStats& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GPURestoreStats* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cedanagpu.GPURestoreStats";
  }
  protected:
  explicit GPURestoreStats(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_gpu_2eproto);
    return ::descriptor_table_gpu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCopyMemTimeFieldNumber = 1,
    kReplayCallsTimeFieldNumber = 2,
  };
  // int64 copyMemTime = 1[json_name = "copyMemTime"];
  void clear_copymemtime();
  ::PROTOBUF_NAMESPACE_ID::int64 copymemtime() const;
  void set_copymemtime(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_copymemtime() const;
  void _internal_set_copymemtime(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 replayCallsTime = 2[json_name = "replayCallsTime"];
  void clear_replaycallstime();
  ::PROTOBUF_NAMESPACE_ID::int64 replaycallstime() const;
  void set_replaycallstime(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_replaycallstime() const;
  void _internal_set_replaycallstime(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:cedanagpu.GPURestoreStats)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 copymemtime_;
  ::PROTOBUF_NAMESPACE_ID::int64 replaycallstime_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gpu_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CheckpointRequest

// string directory = 1[json_name = "directory"];
inline void CheckpointRequest::clear_directory() {
  directory_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& CheckpointRequest::directory() const {
  // @@protoc_insertion_point(field_get:cedanagpu.CheckpointRequest.directory)
  return _internal_directory();
}
inline void CheckpointRequest::set_directory(const std::string& value) {
  _internal_set_directory(value);
  // @@protoc_insertion_point(field_set:cedanagpu.CheckpointRequest.directory)
}
inline std::string* CheckpointRequest::mutable_directory() {
  // @@protoc_insertion_point(field_mutable:cedanagpu.CheckpointRequest.directory)
  return _internal_mutable_directory();
}
inline const std::string& CheckpointRequest::_internal_directory() const {
  return directory_.Get();
}
inline void CheckpointRequest::_internal_set_directory(const std::string& value) {
  
  directory_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CheckpointRequest::set_directory(std::string&& value) {
  
  directory_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:cedanagpu.CheckpointRequest.directory)
}
inline void CheckpointRequest::set_directory(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  directory_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:cedanagpu.CheckpointRequest.directory)
}
inline void CheckpointRequest::set_directory(const char* value,
    size_t size) {
  
  directory_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:cedanagpu.CheckpointRequest.directory)
}
inline std::string* CheckpointRequest::_internal_mutable_directory() {
  
  return directory_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CheckpointRequest::release_directory() {
  // @@protoc_insertion_point(field_release:cedanagpu.CheckpointRequest.directory)
  return directory_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CheckpointRequest::set_allocated_directory(std::string* directory) {
  if (directory != nullptr) {
    
  } else {
    
  }
  directory_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), directory,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:cedanagpu.CheckpointRequest.directory)
}
inline std::string* CheckpointRequest::unsafe_arena_release_directory() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cedanagpu.CheckpointRequest.directory)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return directory_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void CheckpointRequest::unsafe_arena_set_allocated_directory(
    std::string* directory) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (directory != nullptr) {
    
  } else {
    
  }
  directory_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      directory, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cedanagpu.CheckpointRequest.directory)
}

// -------------------------------------------------------------------

// CheckpointResponse

// bool success = 1[json_name = "success"];
inline void CheckpointResponse::clear_success() {
  success_ = false;
}
inline bool CheckpointResponse::_internal_success() const {
  return success_;
}
inline bool CheckpointResponse::success() const {
  // @@protoc_insertion_point(field_get:cedanagpu.CheckpointResponse.success)
  return _internal_success();
}
inline void CheckpointResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void CheckpointResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:cedanagpu.CheckpointResponse.success)
}

// string memPath = 2[json_name = "memPath"];
inline void CheckpointResponse::clear_mempath() {
  mempath_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& CheckpointResponse::mempath() const {
  // @@protoc_insertion_point(field_get:cedanagpu.CheckpointResponse.memPath)
  return _internal_mempath();
}
inline void CheckpointResponse::set_mempath(const std::string& value) {
  _internal_set_mempath(value);
  // @@protoc_insertion_point(field_set:cedanagpu.CheckpointResponse.memPath)
}
inline std::string* CheckpointResponse::mutable_mempath() {
  // @@protoc_insertion_point(field_mutable:cedanagpu.CheckpointResponse.memPath)
  return _internal_mutable_mempath();
}
inline const std::string& CheckpointResponse::_internal_mempath() const {
  return mempath_.Get();
}
inline void CheckpointResponse::_internal_set_mempath(const std::string& value) {
  
  mempath_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CheckpointResponse::set_mempath(std::string&& value) {
  
  mempath_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:cedanagpu.CheckpointResponse.memPath)
}
inline void CheckpointResponse::set_mempath(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  mempath_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:cedanagpu.CheckpointResponse.memPath)
}
inline void CheckpointResponse::set_mempath(const char* value,
    size_t size) {
  
  mempath_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:cedanagpu.CheckpointResponse.memPath)
}
inline std::string* CheckpointResponse::_internal_mutable_mempath() {
  
  return mempath_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CheckpointResponse::release_mempath() {
  // @@protoc_insertion_point(field_release:cedanagpu.CheckpointResponse.memPath)
  return mempath_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CheckpointResponse::set_allocated_mempath(std::string* mempath) {
  if (mempath != nullptr) {
    
  } else {
    
  }
  mempath_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mempath,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:cedanagpu.CheckpointResponse.memPath)
}
inline std::string* CheckpointResponse::unsafe_arena_release_mempath() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cedanagpu.CheckpointResponse.memPath)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return mempath_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void CheckpointResponse::unsafe_arena_set_allocated_mempath(
    std::string* mempath) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (mempath != nullptr) {
    
  } else {
    
  }
  mempath_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      mempath, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cedanagpu.CheckpointResponse.memPath)
}

// string ckptPath = 3[json_name = "ckptPath"];
inline void CheckpointResponse::clear_ckptpath() {
  ckptpath_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& CheckpointResponse::ckptpath() const {
  // @@protoc_insertion_point(field_get:cedanagpu.CheckpointResponse.ckptPath)
  return _internal_ckptpath();
}
inline void CheckpointResponse::set_ckptpath(const std::string& value) {
  _internal_set_ckptpath(value);
  // @@protoc_insertion_point(field_set:cedanagpu.CheckpointResponse.ckptPath)
}
inline std::string* CheckpointResponse::mutable_ckptpath() {
  // @@protoc_insertion_point(field_mutable:cedanagpu.CheckpointResponse.ckptPath)
  return _internal_mutable_ckptpath();
}
inline const std::string& CheckpointResponse::_internal_ckptpath() const {
  return ckptpath_.Get();
}
inline void CheckpointResponse::_internal_set_ckptpath(const std::string& value) {
  
  ckptpath_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CheckpointResponse::set_ckptpath(std::string&& value) {
  
  ckptpath_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:cedanagpu.CheckpointResponse.ckptPath)
}
inline void CheckpointResponse::set_ckptpath(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  ckptpath_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:cedanagpu.CheckpointResponse.ckptPath)
}
inline void CheckpointResponse::set_ckptpath(const char* value,
    size_t size) {
  
  ckptpath_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:cedanagpu.CheckpointResponse.ckptPath)
}
inline std::string* CheckpointResponse::_internal_mutable_ckptpath() {
  
  return ckptpath_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CheckpointResponse::release_ckptpath() {
  // @@protoc_insertion_point(field_release:cedanagpu.CheckpointResponse.ckptPath)
  return ckptpath_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CheckpointResponse::set_allocated_ckptpath(std::string* ckptpath) {
  if (ckptpath != nullptr) {
    
  } else {
    
  }
  ckptpath_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ckptpath,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:cedanagpu.CheckpointResponse.ckptPath)
}
inline std::string* CheckpointResponse::unsafe_arena_release_ckptpath() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cedanagpu.CheckpointResponse.ckptPath)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return ckptpath_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void CheckpointResponse::unsafe_arena_set_allocated_ckptpath(
    std::string* ckptpath) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (ckptpath != nullptr) {
    
  } else {
    
  }
  ckptpath_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ckptpath, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cedanagpu.CheckpointResponse.ckptPath)
}

// -------------------------------------------------------------------

// RestoreRequest

// string directory = 1[json_name = "directory"];
inline void RestoreRequest::clear_directory() {
  directory_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& RestoreRequest::directory() const {
  // @@protoc_insertion_point(field_get:cedanagpu.RestoreRequest.directory)
  return _internal_directory();
}
inline void RestoreRequest::set_directory(const std::string& value) {
  _internal_set_directory(value);
  // @@protoc_insertion_point(field_set:cedanagpu.RestoreRequest.directory)
}
inline std::string* RestoreRequest::mutable_directory() {
  // @@protoc_insertion_point(field_mutable:cedanagpu.RestoreRequest.directory)
  return _internal_mutable_directory();
}
inline const std::string& RestoreRequest::_internal_directory() const {
  return directory_.Get();
}
inline void RestoreRequest::_internal_set_directory(const std::string& value) {
  
  directory_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RestoreRequest::set_directory(std::string&& value) {
  
  directory_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:cedanagpu.RestoreRequest.directory)
}
inline void RestoreRequest::set_directory(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  directory_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:cedanagpu.RestoreRequest.directory)
}
inline void RestoreRequest::set_directory(const char* value,
    size_t size) {
  
  directory_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:cedanagpu.RestoreRequest.directory)
}
inline std::string* RestoreRequest::_internal_mutable_directory() {
  
  return directory_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RestoreRequest::release_directory() {
  // @@protoc_insertion_point(field_release:cedanagpu.RestoreRequest.directory)
  return directory_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RestoreRequest::set_allocated_directory(std::string* directory) {
  if (directory != nullptr) {
    
  } else {
    
  }
  directory_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), directory,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:cedanagpu.RestoreRequest.directory)
}
inline std::string* RestoreRequest::unsafe_arena_release_directory() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cedanagpu.RestoreRequest.directory)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return directory_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void RestoreRequest::unsafe_arena_set_allocated_directory(
    std::string* directory) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (directory != nullptr) {
    
  } else {
    
  }
  directory_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      directory, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cedanagpu.RestoreRequest.directory)
}

// -------------------------------------------------------------------

// RestoreResponse

// bool success = 1[json_name = "success"];
inline void RestoreResponse::clear_success() {
  success_ = false;
}
inline bool RestoreResponse::_internal_success() const {
  return success_;
}
inline bool RestoreResponse::success() const {
  // @@protoc_insertion_point(field_get:cedanagpu.RestoreResponse.success)
  return _internal_success();
}
inline void RestoreResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void RestoreResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:cedanagpu.RestoreResponse.success)
}

// .cedanagpu.GPURestoreStats gpuRestoreStats = 2[json_name = "gpuRestoreStats"];
inline bool RestoreResponse::_internal_has_gpurestorestats() const {
  return this != internal_default_instance() && gpurestorestats_ != nullptr;
}
inline bool RestoreResponse::has_gpurestorestats() const {
  return _internal_has_gpurestorestats();
}
inline void RestoreResponse::clear_gpurestorestats() {
  if (GetArena() == nullptr && gpurestorestats_ != nullptr) {
    delete gpurestorestats_;
  }
  gpurestorestats_ = nullptr;
}
inline const ::cedanagpu::GPURestoreStats& RestoreResponse::_internal_gpurestorestats() const {
  const ::cedanagpu::GPURestoreStats* p = gpurestorestats_;
  return p != nullptr ? *p : *reinterpret_cast<const ::cedanagpu::GPURestoreStats*>(
      &::cedanagpu::_GPURestoreStats_default_instance_);
}
inline const ::cedanagpu::GPURestoreStats& RestoreResponse::gpurestorestats() const {
  // @@protoc_insertion_point(field_get:cedanagpu.RestoreResponse.gpuRestoreStats)
  return _internal_gpurestorestats();
}
inline void RestoreResponse::unsafe_arena_set_allocated_gpurestorestats(
    ::cedanagpu::GPURestoreStats* gpurestorestats) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gpurestorestats_);
  }
  gpurestorestats_ = gpurestorestats;
  if (gpurestorestats) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cedanagpu.RestoreResponse.gpuRestoreStats)
}
inline ::cedanagpu::GPURestoreStats* RestoreResponse::release_gpurestorestats() {
  auto temp = unsafe_arena_release_gpurestorestats();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::cedanagpu::GPURestoreStats* RestoreResponse::unsafe_arena_release_gpurestorestats() {
  // @@protoc_insertion_point(field_release:cedanagpu.RestoreResponse.gpuRestoreStats)
  
  ::cedanagpu::GPURestoreStats* temp = gpurestorestats_;
  gpurestorestats_ = nullptr;
  return temp;
}
inline ::cedanagpu::GPURestoreStats* RestoreResponse::_internal_mutable_gpurestorestats() {
  
  if (gpurestorestats_ == nullptr) {
    auto* p = CreateMaybeMessage<::cedanagpu::GPURestoreStats>(GetArena());
    gpurestorestats_ = p;
  }
  return gpurestorestats_;
}
inline ::cedanagpu::GPURestoreStats* RestoreResponse::mutable_gpurestorestats() {
  // @@protoc_insertion_point(field_mutable:cedanagpu.RestoreResponse.gpuRestoreStats)
  return _internal_mutable_gpurestorestats();
}
inline void RestoreResponse::set_allocated_gpurestorestats(::cedanagpu::GPURestoreStats* gpurestorestats) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete gpurestorestats_;
  }
  if (gpurestorestats) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(gpurestorestats);
    if (message_arena != submessage_arena) {
      gpurestorestats = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gpurestorestats, submessage_arena);
    }
    
  } else {
    
  }
  gpurestorestats_ = gpurestorestats;
  // @@protoc_insertion_point(field_set_allocated:cedanagpu.RestoreResponse.gpuRestoreStats)
}

// -------------------------------------------------------------------

// StartupPollRequest

// -------------------------------------------------------------------

// StartupPollResponse

// bool success = 1[json_name = "success"];
inline void StartupPollResponse::clear_success() {
  success_ = false;
}
inline bool StartupPollResponse::_internal_success() const {
  return success_;
}
inline bool StartupPollResponse::success() const {
  // @@protoc_insertion_point(field_get:cedanagpu.StartupPollResponse.success)
  return _internal_success();
}
inline void StartupPollResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void StartupPollResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:cedanagpu.StartupPollResponse.success)
}

// -------------------------------------------------------------------

// HealthCheckRequest

// -------------------------------------------------------------------

// HealthCheckResponse

// bool success = 1[json_name = "success"];
inline void HealthCheckResponse::clear_success() {
  success_ = false;
}
inline bool HealthCheckResponse::_internal_success() const {
  return success_;
}
inline bool HealthCheckResponse::success() const {
  // @@protoc_insertion_point(field_get:cedanagpu.HealthCheckResponse.success)
  return _internal_success();
}
inline void HealthCheckResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void HealthCheckResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:cedanagpu.HealthCheckResponse.success)
}

// string version = 2[json_name = "version"];
inline void HealthCheckResponse::clear_version() {
  version_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& HealthCheckResponse::version() const {
  // @@protoc_insertion_point(field_get:cedanagpu.HealthCheckResponse.version)
  return _internal_version();
}
inline void HealthCheckResponse::set_version(const std::string& value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:cedanagpu.HealthCheckResponse.version)
}
inline std::string* HealthCheckResponse::mutable_version() {
  // @@protoc_insertion_point(field_mutable:cedanagpu.HealthCheckResponse.version)
  return _internal_mutable_version();
}
inline const std::string& HealthCheckResponse::_internal_version() const {
  return version_.Get();
}
inline void HealthCheckResponse::_internal_set_version(const std::string& value) {
  
  version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void HealthCheckResponse::set_version(std::string&& value) {
  
  version_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:cedanagpu.HealthCheckResponse.version)
}
inline void HealthCheckResponse::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:cedanagpu.HealthCheckResponse.version)
}
inline void HealthCheckResponse::set_version(const char* value,
    size_t size) {
  
  version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:cedanagpu.HealthCheckResponse.version)
}
inline std::string* HealthCheckResponse::_internal_mutable_version() {
  
  return version_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* HealthCheckResponse::release_version() {
  // @@protoc_insertion_point(field_release:cedanagpu.HealthCheckResponse.version)
  return version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void HealthCheckResponse::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:cedanagpu.HealthCheckResponse.version)
}
inline std::string* HealthCheckResponse::unsafe_arena_release_version() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cedanagpu.HealthCheckResponse.version)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return version_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void HealthCheckResponse::unsafe_arena_set_allocated_version(
    std::string* version) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (version != nullptr) {
    
  } else {
    
  }
  version_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      version, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cedanagpu.HealthCheckResponse.version)
}

// int32 deviceCount = 3[json_name = "deviceCount"];
inline void HealthCheckResponse::clear_devicecount() {
  devicecount_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HealthCheckResponse::_internal_devicecount() const {
  return devicecount_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HealthCheckResponse::devicecount() const {
  // @@protoc_insertion_point(field_get:cedanagpu.HealthCheckResponse.deviceCount)
  return _internal_devicecount();
}
inline void HealthCheckResponse::_internal_set_devicecount(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  devicecount_ = value;
}
inline void HealthCheckResponse::set_devicecount(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_devicecount(value);
  // @@protoc_insertion_point(field_set:cedanagpu.HealthCheckResponse.deviceCount)
}

// .cedanagpu.AvailableCUDAAPIs availableCUDAAPIs = 4[json_name = "availableCUDAAPIs"];
inline bool HealthCheckResponse::_internal_has_availablecudaapis() const {
  return this != internal_default_instance() && availablecudaapis_ != nullptr;
}
inline bool HealthCheckResponse::has_availablecudaapis() const {
  return _internal_has_availablecudaapis();
}
inline void HealthCheckResponse::clear_availablecudaapis() {
  if (GetArena() == nullptr && availablecudaapis_ != nullptr) {
    delete availablecudaapis_;
  }
  availablecudaapis_ = nullptr;
}
inline const ::cedanagpu::AvailableCUDAAPIs& HealthCheckResponse::_internal_availablecudaapis() const {
  const ::cedanagpu::AvailableCUDAAPIs* p = availablecudaapis_;
  return p != nullptr ? *p : *reinterpret_cast<const ::cedanagpu::AvailableCUDAAPIs*>(
      &::cedanagpu::_AvailableCUDAAPIs_default_instance_);
}
inline const ::cedanagpu::AvailableCUDAAPIs& HealthCheckResponse::availablecudaapis() const {
  // @@protoc_insertion_point(field_get:cedanagpu.HealthCheckResponse.availableCUDAAPIs)
  return _internal_availablecudaapis();
}
inline void HealthCheckResponse::unsafe_arena_set_allocated_availablecudaapis(
    ::cedanagpu::AvailableCUDAAPIs* availablecudaapis) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(availablecudaapis_);
  }
  availablecudaapis_ = availablecudaapis;
  if (availablecudaapis) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cedanagpu.HealthCheckResponse.availableCUDAAPIs)
}
inline ::cedanagpu::AvailableCUDAAPIs* HealthCheckResponse::release_availablecudaapis() {
  auto temp = unsafe_arena_release_availablecudaapis();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::cedanagpu::AvailableCUDAAPIs* HealthCheckResponse::unsafe_arena_release_availablecudaapis() {
  // @@protoc_insertion_point(field_release:cedanagpu.HealthCheckResponse.availableCUDAAPIs)
  
  ::cedanagpu::AvailableCUDAAPIs* temp = availablecudaapis_;
  availablecudaapis_ = nullptr;
  return temp;
}
inline ::cedanagpu::AvailableCUDAAPIs* HealthCheckResponse::_internal_mutable_availablecudaapis() {
  
  if (availablecudaapis_ == nullptr) {
    auto* p = CreateMaybeMessage<::cedanagpu::AvailableCUDAAPIs>(GetArena());
    availablecudaapis_ = p;
  }
  return availablecudaapis_;
}
inline ::cedanagpu::AvailableCUDAAPIs* HealthCheckResponse::mutable_availablecudaapis() {
  // @@protoc_insertion_point(field_mutable:cedanagpu.HealthCheckResponse.availableCUDAAPIs)
  return _internal_mutable_availablecudaapis();
}
inline void HealthCheckResponse::set_allocated_availablecudaapis(::cedanagpu::AvailableCUDAAPIs* availablecudaapis) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete availablecudaapis_;
  }
  if (availablecudaapis) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(availablecudaapis);
    if (message_arena != submessage_arena) {
      availablecudaapis = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, availablecudaapis, submessage_arena);
    }
    
  } else {
    
  }
  availablecudaapis_ = availablecudaapis;
  // @@protoc_insertion_point(field_set_allocated:cedanagpu.HealthCheckResponse.availableCUDAAPIs)
}

// -------------------------------------------------------------------

// AvailableCUDAAPIs

// int32 cuDNNVersion = 1[json_name = "cuDNNVersion"];
inline void AvailableCUDAAPIs::clear_cudnnversion() {
  cudnnversion_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AvailableCUDAAPIs::_internal_cudnnversion() const {
  return cudnnversion_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AvailableCUDAAPIs::cudnnversion() const {
  // @@protoc_insertion_point(field_get:cedanagpu.AvailableCUDAAPIs.cuDNNVersion)
  return _internal_cudnnversion();
}
inline void AvailableCUDAAPIs::_internal_set_cudnnversion(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  cudnnversion_ = value;
}
inline void AvailableCUDAAPIs::set_cudnnversion(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_cudnnversion(value);
  // @@protoc_insertion_point(field_set:cedanagpu.AvailableCUDAAPIs.cuDNNVersion)
}

// int32 cuBLASVersion = 2[json_name = "cuBLASVersion"];
inline void AvailableCUDAAPIs::clear_cublasversion() {
  cublasversion_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AvailableCUDAAPIs::_internal_cublasversion() const {
  return cublasversion_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AvailableCUDAAPIs::cublasversion() const {
  // @@protoc_insertion_point(field_get:cedanagpu.AvailableCUDAAPIs.cuBLASVersion)
  return _internal_cublasversion();
}
inline void AvailableCUDAAPIs::_internal_set_cublasversion(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  cublasversion_ = value;
}
inline void AvailableCUDAAPIs::set_cublasversion(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_cublasversion(value);
  // @@protoc_insertion_point(field_set:cedanagpu.AvailableCUDAAPIs.cuBLASVersion)
}

// int32 ncclVersion = 3[json_name = "ncclVersion"];
inline void AvailableCUDAAPIs::clear_ncclversion() {
  ncclversion_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AvailableCUDAAPIs::_internal_ncclversion() const {
  return ncclversion_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AvailableCUDAAPIs::ncclversion() const {
  // @@protoc_insertion_point(field_get:cedanagpu.AvailableCUDAAPIs.ncclVersion)
  return _internal_ncclversion();
}
inline void AvailableCUDAAPIs::_internal_set_ncclversion(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  ncclversion_ = value;
}
inline void AvailableCUDAAPIs::set_ncclversion(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_ncclversion(value);
  // @@protoc_insertion_point(field_set:cedanagpu.AvailableCUDAAPIs.ncclVersion)
}

// int32 driverVersion = 4[json_name = "driverVersion"];
inline void AvailableCUDAAPIs::clear_driverversion() {
  driverversion_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AvailableCUDAAPIs::_internal_driverversion() const {
  return driverversion_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AvailableCUDAAPIs::driverversion() const {
  // @@protoc_insertion_point(field_get:cedanagpu.AvailableCUDAAPIs.driverVersion)
  return _internal_driverversion();
}
inline void AvailableCUDAAPIs::_internal_set_driverversion(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  driverversion_ = value;
}
inline void AvailableCUDAAPIs::set_driverversion(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_driverversion(value);
  // @@protoc_insertion_point(field_set:cedanagpu.AvailableCUDAAPIs.driverVersion)
}

// int32 runtimeVersion = 5[json_name = "runtimeVersion"];
inline void AvailableCUDAAPIs::clear_runtimeversion() {
  runtimeversion_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AvailableCUDAAPIs::_internal_runtimeversion() const {
  return runtimeversion_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AvailableCUDAAPIs::runtimeversion() const {
  // @@protoc_insertion_point(field_get:cedanagpu.AvailableCUDAAPIs.runtimeVersion)
  return _internal_runtimeversion();
}
inline void AvailableCUDAAPIs::_internal_set_runtimeversion(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  runtimeversion_ = value;
}
inline void AvailableCUDAAPIs::set_runtimeversion(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_runtimeversion(value);
  // @@protoc_insertion_point(field_set:cedanagpu.AvailableCUDAAPIs.runtimeVersion)
}

// -------------------------------------------------------------------

// GPURestoreStats

// int64 copyMemTime = 1[json_name = "copyMemTime"];
inline void GPURestoreStats::clear_copymemtime() {
  copymemtime_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GPURestoreStats::_internal_copymemtime() const {
  return copymemtime_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GPURestoreStats::copymemtime() const {
  // @@protoc_insertion_point(field_get:cedanagpu.GPURestoreStats.copyMemTime)
  return _internal_copymemtime();
}
inline void GPURestoreStats::_internal_set_copymemtime(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  copymemtime_ = value;
}
inline void GPURestoreStats::set_copymemtime(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_copymemtime(value);
  // @@protoc_insertion_point(field_set:cedanagpu.GPURestoreStats.copyMemTime)
}

// int64 replayCallsTime = 2[json_name = "replayCallsTime"];
inline void GPURestoreStats::clear_replaycallstime() {
  replaycallstime_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GPURestoreStats::_internal_replaycallstime() const {
  return replaycallstime_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GPURestoreStats::replaycallstime() const {
  // @@protoc_insertion_point(field_get:cedanagpu.GPURestoreStats.replayCallsTime)
  return _internal_replaycallstime();
}
inline void GPURestoreStats::_internal_set_replaycallstime(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  replaycallstime_ = value;
}
inline void GPURestoreStats::set_replaycallstime(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_replaycallstime(value);
  // @@protoc_insertion_point(field_set:cedanagpu.GPURestoreStats.replayCallsTime)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace cedanagpu

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_gpu_2eproto
